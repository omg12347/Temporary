# -*- coding: utf-8 -*-
"""AI-lab7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dtRMm8L0YCBxTg3UDKgK-6MfMm0Z0A5e

Roll No.: 66

Name: Atharva Werulkar

Sem: 4th

Batch: E3

Lab-7

Aim:- Apply A* search on Romania Map
"""

import heapq


romania_map = {
    "Arad": {"Zerind": 75, "Sibiu": 140, "Timisoara": 118},
    "Zerind": {"Oradea": 71, "Arad": 75},
    "Oradea": {"Zerind": 71, "Sibiu": 151},
    "Sibiu": {"Arad": 140, "Oradea": 151, "Fagaras": 99, "Rimnicu Vilcea": 80},
    "Timisoara": {"Arad": 118, "Lugoj": 111},
    "Lugoj": {"Timisoara": 111, "Mehadia": 70},
    "Mehadia": {"Lugoj": 70, "Drobeta": 75},
    "Drobeta": {"Mehadia": 75, "Craiova": 120},
    "Craiova": {"Drobeta": 120, "Rimnicu Vilcea": 146, "Pitesti": 138},
    "Rimnicu Vilcea": {"Sibiu": 80, "Craiova": 146, "Pitesti": 97},
    "Fagaras": {"Sibiu": 99, "Bucharest": 211},
    "Pitesti": {"Rimnicu Vilcea": 97, "Craiova": 138, "Bucharest": 101},
    "Bucharest": {"Fagaras": 211, "Pitesti": 101, "Giurgiu": 90, "Urziceni": 85},
    "Giurgiu": {"Bucharest": 90},
    "Urziceni": {"Bucharest": 85, "Hirsova": 98, "Vaslui": 142},
    "Hirsova": {"Urziceni": 98, "Eforie": 86},
    "Eforie": {"Hirsova": 86},
    "Vaslui": {"Urziceni": 142, "Iasi": 92},
    "Iasi": {"Vaslui": 92, "Neamt": 87},
    "Neamt": {"Iasi": 87}
}


heuristics = {
    "Arad": 366,
    "Bucharest": 0,
    "Craiova": 160,
    "Drobeta": 242,
    "Eforie": 161,
    "Fagaras": 176,
    "Giurgiu": 77,
    "Hirsova": 151,
    "Iasi": 226,
    "Lugoj": 244,
    "Mehadia": 241,
    "Neamt": 234,
    "Oradea": 380,
    "Pitesti": 100,
    "Rimnicu Vilcea": 193,
    "Sibiu": 253,
    "Timisoara": 329,
    "Urziceni": 80,
    "Vaslui": 199,
    "Zerind": 374
}


def a_star(graph, start, goal, heuristics):
    # Priority queue for open nodes
    open_nodes = [(0, start)]

    path_cost = {start: (None, 0)}

    visited = set()

    while open_nodes:
        current_cost, current_node = heapq.heappop(open_nodes)
        visited.add(current_node)

        if current_node == goal:
            path = []
            while current_node:
                path.append(current_node)
                current_node, _ = path_cost[current_node]
            path.reverse()
            return path

        for neighbor, distance in graph[current_node].items():
            if neighbor not in visited:
                new_cost = path_cost[current_node][1] + distance
                if neighbor not in path_cost or new_cost < path_cost[neighbor][1]:
                    # Update the path and cost
                    path_cost[neighbor] = (current_node, new_cost)
                    # Calculate the total cost f(n) = (g(n) + h(n))
                    total_cost = new_cost + heuristics[neighbor]
                    heapq.heappush(open_nodes, (total_cost, neighbor))

    return None


# Test the A* algorithm on the Romania graph
start_city = 'Arad'
goal_city = 'Bucharest'

path = a_star(romania_map, start_city, goal_city, heuristics)

if path:
    print(f"Shortest path from {start_city} to {goal_city}:")
    print(" ðŸ‘‰ ".join(path))
else:
    print(f"No path found from {start_city} to {goal_city}.")