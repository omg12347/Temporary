# -*- coding: utf-8 -*-
"""AI-lab4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PovNoZPeqICjV-qwgIq8bzFFDlz4MUIk

Roll No.: 66

Name: Atharva Werulkar

Sem: 4th

Batch: E4

Lab-4

Aim:- Solve 8 Puzzle Problem using A*
"""

from queue import PriorityQueue
import numpy as np

def solve_8_puzzle(initial_state, goal_state, heuristic):
    priority_queue = PriorityQueue()
    cost = {}
    moves = {}

    priority_queue.put((heuristic(initial_state), initial_state))
    cost[initial_state] = 0
    moves[initial_state] = []

    while not priority_queue.empty():
        current_state = priority_queue.get()[1]
        print_state(current_state, heuristic(current_state))

        if current_state == goal_state:
            return moves[current_state]

        next_states = generate_next_states(current_state)

        for next_state in next_states:

            new_cost = cost[current_state] + 1
            if next_state not in cost or new_cost < cost[next_state]:

                cost[next_state] = new_cost
                moves[next_state] = moves[current_state] + [next_state]

                priority = new_cost + heuristic(next_state)

                priority_queue.put((priority, next_state))

    return "No solution found."

def print_state(state, heuristic_value):
    print("State Generated:")
    for row in state:
        print(row)
    print("Heuristic Value:", heuristic_value)
    print()

def generate_next_states(state):
    next_states = []
    empty_row, empty_col = find_empty_space(state)
    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for move in moves:
        new_row = empty_row + move[0]
        new_col = empty_col + move[1]

        if is_valid_move(new_row, new_col):
            new_state = swap_tiles(state, empty_row, empty_col, new_row, new_col)
            next_states.append(new_state)

    return next_states

def find_empty_space(state):
    for row in range(3):
        for col in range(3):
            if state[row][col] == 0:
                return row, col

def is_valid_move(row, col):
    return 0 <= row < 3 and 0 <= col < 3

def swap_tiles(state, row1, col1, row2, col2):
    new_state = [list(row) for row in state]
    new_state[row1][col1], new_state[row2][col2] = new_state[row2][col2], new_state[row1][col1]
    return tuple(tuple(row) for row in new_state)

def manhattan_distance(state):
    distance = 0
    for row in range(3):
        for col in range(3):
            tile = state[row][col]
            if tile != 0:
                target_row = (tile - 1) // 3
                target_col = (tile - 1) % 3
                distance += abs(row - target_row) + abs(col - target_col)
    return distance

initial_state = ((1, 2, 3), (4, 5, 6), (7, 0, 8))
goal_state = ((1, 2, 3), (4, 5, 6), (7, 8, 0))

print("Initial State:")
for row in initial_state:
    print(row)
print
result = solve_8_puzzle(initial_state, goal_state, manhattan_distance)

for matrix in result:
    print("Goal Reached:")
    for row in matrix:
        print(row)